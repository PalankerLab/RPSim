import numpy as np
import matplotlib.pyplot as plt
import copy

from configuration.models import Models
from configuration.stages import RunStages
from configuration.configuration_manager import Configuration

from run_stages.common_run_stage import CommonRunStage
from utilities.image_processing_utilities import int_sq


class ResistiveMeshStage(CommonRunStage):
	"""
	This class implements the logic for the resistive mesh stage while abiding by the structure required by the
	common run stage
	"""
	@property
	def stage_name(self):
		return RunStages.resistive_mesh.name

	def run_stage(self):
		"""
		This function holds the execution logic for the resistive mesh stage
		:param args:
		:param kwargs:
		:return:
		"""
		return self._build_interconnected_mesh()

	@staticmethod
	def _build_interconnected_mesh():
		"""
		This function is the heart of this stage.
		It converts the R matrix into a symmetric interconnected mesh of resistors
		:return:
		"""
		if Configuration().params["model"] == Models.MONOPOLAR.value:
			# load the non-diagonal entries of the R matrix. The first 3 columns are coordinates
			R = np.loadtxt(Configuration().params["r_matrix_input_file_non_diagonal"], delimiter=',')

			# load the diagonal entries of the R matrix. The first 2 columns are coordinates
			R_dia = np.loadtxt(Configuration().params["r_matrix_input_file_diagonal"], delimiter=',')

			# All potentials are referenced to the return mesh of the elementary field (column 3 of R_dia)
			R = R[:, 3:] - R_dia[:, 3]
			# Column 2 of R_dia contains the average potential on each active electrode.
			R_dia = R_dia[:, 2] - R_dia[:, 3]
			np.fill_diagonal(R, R_dia)

		if Configuration().params["model"] == Models.BIPOLAR.value:
			# load the axially symmetric field generated by a single active electrode
			dat_active = np.loadtxt(Configuration().params["r_matrix_input_file_active"], delimiter=',')
			# load the  axially symmetric far field generated by a single return electrode
			dat_return = np.loadtxt(Configuration().params["r_matrix_input_file_return"], delimiter=',')
			# load the near field generated by a single return electrode
			dat_return_neighbor = np.loadtxt(Configuration().params["r_matrix_input_file_return_neighbor"], delimiter=',')
			# load the coordinates of all pixels
			px_pos = np.loadtxt(Configuration().params["r_matrix_input_file_px_pos"], delimiter=',')

			active_r = Configuration().params["active_electrode_radius"]
			return_w = (Configuration().params["pixel_size"] - Configuration().params["photosensitive_area_edge_to_edge"]) / 2
			px_size = Configuration().params["pixel_size"]
			N_px = px_pos.shape[0]

			# distance and potential from the center of an active electrode
			X_act = dat_active[0,:]
			V_act = dat_active[1,:]
			# distance and potential from the center of a return hexagon
			X_ret = dat_return[0,:]
			V_ret = dat_return[1,:]
			# determine the self-resistance of the active
			X_idx = X_act<active_r
			Rself_act = int_sq(X_act[X_idx], V_act[X_idx])
			# cross-pixel resistance from the return to the active of the same pixel 
			Rself_ra = int_sq(X_ret[X_idx], V_ret[X_idx])
			# self-resistance of an return hexagon
			Rself_ret = dat_return_neighbor[0]
			# cross-pixel resistance from the return to the active of the same pixel 
			return_r = px_size*(.5+np.tan(np.pi/6))/2
			X_idx = (X_ret<=return_r)&(X_ret>return_r-return_w)
			Rself_ar = int_sq(X_act[X_idx], V_act[X_idx])

			# interprelate far-field entries
			x_dist = px_pos[:,0].reshape((N_px, 1)) - px_pos[:,0].reshape((1, N_px))
			y_dist = px_pos[:,1].reshape((N_px, 1)) - px_pos[:,1].reshape((1, N_px))
			dist = np.sqrt(x_dist**2 + y_dist**2)
			R_act =  np.interp(dist, X_act, V_act)
			R_ret =  np.interp(dist, X_ret, V_ret)

			# cross-pixel resistance to a return hexagon from the 3 nearest neighbor returns
			neighbor1_idx = np.abs(dist - px_size)<1E-3
			neighbor2_idx = np.abs(dist - 2*px_size)<1E-3
			neighbor3_idx = np.abs(dist - np.sqrt(3)*px_size)<1E-3
			R_ret[neighbor1_idx] = dat_return_neighbor[1]
			R_ret[neighbor2_idx] = dat_return_neighbor[2]
			R_ret[neighbor3_idx] = dat_return_neighbor[3]

			# cross-pixel resistance between active and return
			R12 = copy.deepcopy(R_act)
			R21 = copy.deepcopy(R_ret)
			np.fill_diagonal(R12, Rself_ar*np.ones(N_px))
			np.fill_diagonal(R21, Rself_ra*np.ones(N_px))
			np.fill_diagonal(R_act, Rself_act*np.ones(N_px))
			np.fill_diagonal(R_ret, Rself_ret*np.ones(N_px))

			# 2Nx2N impedance matrix
			R = np.concatenate((np.concatenate((R_act, R12)), np.concatenate((R21, R_ret))), axis=1)

		# force symmetry	
		R = (R + R.T) / 2
		# convert the impedance matrix to resistor mesh. see [Z.C. Chen, et al, 2022] for the theory.
		G = np.linalg.inv(R)
		S = - G
		np.fill_diagonal(S, G.sum(axis=1))
		r_dual = 1 / S

		return [r_dual / Configuration().params["r_matrix_conductivity"] * 1E3]

	# TODO: incorporate in plot results
	@staticmethod
	def plot_resistive_mesh(resistive_mesh):
		# Just for visualization of the resistors in the mesh. optional
		plt.plot(np.diag(resistive_mesh * 1E-6), label='$R_{n,n}$')
		plt.xlabel('Pixel Index')
		plt.ylabel('Resistance (M$\Omega$)')
		plt.legend()
